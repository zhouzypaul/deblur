"""
This file handles the debluring of images
this is where the magic comes together
"""
import cv2
import numpy as np
from scipy import optimize
import matplotlib.pyplot as plt

import util
import params as hp
from get_data import parse_dataset


def estimating_latent_image_with_blur_kernel(blur_img, kernel):
    """
    this function estimates the latent clean image using the kernel as input
    this is algorithm 1 and section 3.1 in the paper
    args:
        blur_img: the blur image
        kernel: the blur kernel
    return:
        intermediate latente image
    """
    latent_img = blur_img
    beta = 2 * hp.lmda * hp.sigma
    # repeat 
    while beta <= hp.beta_max:
        # solve for u using (10)
        u = util.get_u(latent_img, beta)
        miu = 2 * hp.lmda

        # repeat
        while miu <= hp.miu_max:
            # solve for g using (11)
            g = util.get_g(latent_img, miu)
            # solve for x using (8)
            latent_img = util.get_latent(u, g, latent_img, blur_img, kernel, beta, miu)
            miu = 2 * miu
        beta = 2 * beta
    return latent_img


# ==============================================================================
num_iters = 5
gamma = 1.0
kernel_size = (15, 15)

# TODO: decide on variable names, for now use paper conventions:
# x -> latent image
# y -> blur image
# k -> blur kernel


def deblur(y):
    """
    this function deblurs an image by eestimating the blur kernel using 
    a coarse-to-fine image pyramid approach

    this is section 3.2 in the paper
    args:
        y: the blur image
    return:
        final blur kernel and list of estimated latent images
    """

    # image pyramid generated by downsampling blur_img
    image_pyramid = generate_image_pyramid(y)

    # previous blur_kernel
    k = init_kernel()

    # intermediate latent images
    latent_imgs = []

    # coarse to fine
    for y in reversed(image_pyramid):

        # TODO: potentially need to resize kernel, estimated latent, and blurred image?

        # perform Algorithm 2 to estimate intermediate estimated latent and blur kernel
        k, x = estimate_blur_kernel(y, k)

        latent_imgs.append(x)

    # perform final deconvolve using final estimated kernel
    k, final_deblurred = estimate_blur_kernel(y, k)
    latent_imgs.append(final_deblurred)

    return k, latent_imgs


def estimate_blur_kernel(y, k):
    """
    this function estimates the blur kernel using an interative process as
    outlined in Algorithm 2 of the paper
    args:
        y: the blur image
        k: the blur kernel estimate
    return:
        blur kernel and intermediate latent image
    """
    # intermediate latent image
    x = None

    # preset number of iterations, paper uses 5
    for _ in range(5):

        # solve for x using Algorithm 1
        x = estimating_latent_image_with_blur_kernel(y, k)

        # solve for k, update kernel estimate eq. (12)
        # use FFT to estimate blur kernel, look at 'estimate_psf'
        k = solve_kernel(y, x)

        # update lambda hyperparameter
        lmda = max(lmda / 1.1, 1e-4)

    return k, x


def generate_image_pyramid(y):
    '''
    Repeatedly downsamples blurred image with bilinear interpolation
    y: single image - numpy array
    '''
    img = y.copy()
    try:
        assert isinstance(img, np.ndarray)
    except AssertionError:
        img = np.array(img)
    image_pyramid = [img]

    # downsample for fixed number of layers
    for _ in range(5):
        layer = cv2.pyrDown(np.array(image_pyramid[-1]))
        layer = cv2.pyrUp(layer)
        image_pyramid.append(layer)

    return image_pyramid


def init_kernel():
    '''
    initializes kernel
    '''
    return np.ones(kernel_size)


def solve_kernel(y, x):
    '''
    this function estimates the blur kernel efficiently in gradient space using 
    conjugate gradient method
    '''
    A = util.get_gradient(x)
    b = util.get_gradient(y)

    def pad_and_flatten_kernel(kernel, out_size):
        """
        pad and flatten the kernel to a 1D array as described in Fast Motion Deblurring
        """
        padded_kernel = util.pad_kernel(kernel, out_size)
        return padded_kernel.flatten()
        

    def objective_function(kernel):
        """
        objective function as described in equaiton (8) from Fast Motion Deblurring
        """
        # kernel = pad_and_flatten_kernel(kernel, y.shape)
        return (A @ kernel - b).T @ (A @ kernel - b) + hp.gamma * kernel.T @ kernel

    def get_function_gradient(kernel):
        """
        get the gradient as described in equation (9) from Fast Motion Deblurring
        """
        # kernel = pad_and_flatten_kernel(kernel, y.shape)
        return 2 * A.T @ A @ kernel - 2 * hp.gamma * kernel - 2 * A.T @ b
    
    guessed_value = pad_and_flatten_kernel(np.zeros(kernel_size), y.shape)
    solved_kernel = optimize.fmin_cg(
        f=objective_function,
        x0=guessed_value,
        fprime=get_function_gradient,
    )
    return solved_kernel


def remove_artifact(blur_img):
    """
    this removes the artifacts as detailed in section 3.3 of the paper
    """
    # TODO: Luca
    pass


def main(data_path='data/original_images/'):
    """
    interleave kernel and latent image estimation
    load the original images and deblur them, and plot them together
    """
    ground_truth_images, blurred_images = parse_dataset(image_path='data/ieee2016/text-images/gt_images', kernel_path='data/ieee2016/text-images/kernels')  # there should be 15 of them
    for img in blurred_images:
        blur_kernel, restored_img = deblur(img)
        for latent_img in restored_img:
            plt.imshow(latent_img)
        plt.show()
        plt.close()

    # test for image pyramid
    # img = cv2.imread('Alan_Kumon_W2_2019.png')
    # cv2.imshow("original image", img)

    # pyramid = generate_image_pyramid(img)
    # for i, img in enumerate(pyramid):
    #     cv2.imshow(str(i) + "image", img)

    # cv2.waitKey(0)
    # cv2.destroyAllWindows()


if __name__ == "__main__":
    main()
